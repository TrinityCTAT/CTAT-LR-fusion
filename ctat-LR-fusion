#!/usr/bin/env perl

use strict;
use warnings;
use Carp;
use Getopt::Long qw(:config no_ignore_case bundling pass_through);
use FindBin;
use Cwd;
use lib ("$FindBin::Bin/PerlLib");
use Pipeliner;
use Process_cmd;
use File::Basename;

my $VERSION = "v0.1.0";


my $CPU = 4;
my $MIN_TRANS_LEN_TRY_CHIM = 30;
my $output_directory = "ctat_LR_fusion_outdir";
my $MIN_NOVEL_J = 3;
my $MIN_J = 1;
my $MIN_SUM_JS = 1;

my $MIN_PER_ID = 90;

my $SPLIT_BREAKPOINT_EXTEND_LENGTH = 25;
my $MAX_FUZZY_OVERLAP = 12;


my $usage = <<__EOUSAGE__;

############################################################################################################
#
#  Required:
#
#  --transcripts|T <string>        :transcript fasta or fastq file
#
#  --genome_lib_dir <string>             directory containing genome lib (see http://FusionFilter.github.io for details)
#
#  Optional:
#
#  --CPU <int>                     :number threads (default $CPU)
#
#  --left_fq <string>              :Illumina paired-end reads /1
#
#  --right_fq <string>             :Illumina paired-end reads /2
#
#  --min_per_id <int>              :minimum percent identity (default: $MIN_PER_ID)
#
#  --min_chim_len|L <int>            :minimum length for a chimeric alignment (default: $MIN_TRANS_LEN_TRY_CHIM)
#
#  --output|o <string>             :output directory name (default: $output_directory)
#
#   
#  --min_J <int>                 :minimum number of junction frags (default: $MIN_J)  
#
#  --min_sumJS <int>             :minimum sum (junction + spanning) frags (default: $MIN_SUM_JS)
#
#  --min_novel_junction_support <int>   :minimum number of junction reads required for novel (non-reference) exon-exon junction support.
#                                        (default: $MIN_NOVEL_J)
#  --split_breakpoint_extend_length <int>   :in assessing breakpoint quality, the length to extend each split sequence beyond
#                                           the proposed breakpoint. (default: $SPLIT_BREAKPOINT_EXTEND_LENGTH)
#
#  --max_fuzzy_overlap <int>               :maximum allowed overlap of extended length from breakpoint (default: $MAX_FUZZY_OVERLAP)
#
#  --no_annot_filter               : disable filtering outputs based on fusion annotations.
#
#  --prep_reference                : prepares mininmap2 genome index
#  --prep_reference_only           : only prepares genome index and then stops.
#
#  --version                             report version ($VERSION)
#
##############################################################################################################



__EOUSAGE__

    ;


my $help_flag;
my $transcripts_file;
my $left_fq = "NA";
my $right_fq = "NA";

my $DEBUG = 0;
my $genome_lib_dir;

my $SHOW_VERSION = 0;
my $NO_ANNOTATION_FILTER = 0;

my $PREP_REFERENCE = 0;
my $PREP_REFERENCE_ONLY = 0;

my $max_intron_length = 100000;
my $shrink_intron_max_length = 1000;


&GetOptions ( 'help|h' => \$help_flag,

              ## Required
              'transcripts|T=s' => \$transcripts_file,
              'genome_lib_dir=s' => \$genome_lib_dir,
              
              'left_fq=s' => \$left_fq,
              'right_fq=s' => \$right_fq,

              ## optional
              'CPU=i' => \$CPU,
              'min_chim_len|L=i' => \$MIN_TRANS_LEN_TRY_CHIM,
              'output|o=s' => \$output_directory,
              'min_J=i' => \$MIN_J,
              'min_sumJS=i' => \$MIN_SUM_JS,
              'min_per_id=i' => \$MIN_PER_ID,
              'min_novel_junction_support=i' => \$MIN_NOVEL_J,
              'split_breakpoint_extend_length=i' => \$SPLIT_BREAKPOINT_EXTEND_LENGTH,
              'max_fuzzy_overlap=i' => \$MAX_FUZZY_OVERLAP,
              'version' => \$SHOW_VERSION,
              
              'no_annot_filter' => \$NO_ANNOTATION_FILTER,
              'DEBUG' => \$DEBUG,
              
              'prep_reference' => \$PREP_REFERENCE,
              'prep_reference_only' => \$PREP_REFERENCE_ONLY,

              'shrink_intron_max_length=i' => \$shrink_intron_max_length,
              

);



if ($help_flag) {
    die $usage;
}

if ($SHOW_VERSION) {
    print "\n\nctat-LR-fusion $VERSION\n\n";
    exit(0);
}


unless ($transcripts_file && $genome_lib_dir) {
    die $usage;
}

$genome_lib_dir = &ensure_full_path($genome_lib_dir);

$transcripts_file = &ensure_full_path($transcripts_file);
if ($left_fq ne "NA") {
    $left_fq = &ensure_full_path($left_fq);
}
if ($right_fq ne "NA") {
    $right_fq = &ensure_full_path($right_fq);
}


my $long_reads_only_flag = ($left_fq eq "NA" && $right_fq eq "NA") ? 1:0;


my $UTILDIR = "$FindBin::RealBin/util";
my $FI_DIR = "$FindBin::RealBin/FusionInspector";
my $CTAT_MINIMAP2_DIR = "$FindBin::RealBin/ctat-minimap2";

my $MM2_DB_DIR = $genome_lib_dir;
my $MM2_DB_NAME = "ref_genome.fa.mm2";

my $REF_GTF = "$genome_lib_dir/ref_annot.gtf";
unless (-s $REF_GTF) {
    die "Error, cannot locate reference annotation file: $REF_GTF";
}

my $MM2_splice_file = "$REF_GTF.mm2.splice.bed";
my $genome_fa = "$genome_lib_dir/ref_genome.fa";

if ($PREP_REFERENCE || $PREP_REFERENCE_ONLY) {
    &prep_minimap2_reference($genome_fa, $MM2_DB_DIR, $MM2_DB_NAME, $MM2_splice_file, $REF_GTF);
    if ($PREP_REFERENCE_ONLY) {
        print STDERR "-option --prep_reference_only flag set. Stopping now.\n";
        exit(0);
    }
}

my $MM2_idx = "$MM2_DB_DIR/$MM2_DB_NAME";
unless (-e $MM2_idx) {
    die "Error, cannot locate minimap2 database: $MM2_idx";
}

unless (-e $MM2_splice_file) {
    die "Error, cannot locate file: $MM2_splice_file";
}


if ($output_directory) {
    $output_directory = &ensure_full_path($output_directory);
    
    unless (-d $output_directory) {
        mkdir $output_directory or die "Error, cannot mkdir $output_directory";
    }
    chdir $output_directory or die "Error, cannot cd to $output_directory";
}

my $intermediates_dir = &ensure_full_path("fusion_intermediates_dir");
unless (-d $intermediates_dir) {
    mkdir $intermediates_dir or die "Error, cannot mkdir $intermediates_dir";
}



main: {

    my $pipeliner = new Pipeliner(-verbose => 2,
                                  -checkpoint_dir => "$intermediates_dir/__checkpts",
        );
    
    # make fasta file from fastq
    
    print STDERR "-transcripts filename before: [$transcripts_file]\n";
    # first, check if gzipped.
    if ($transcripts_file =~ /\.gz$/) {
        my $uncompressed_transcripts_file = basename($transcripts_file);
        $uncompressed_transcripts_file =~ s/\.gz$//;
        my $cmd = "gunzip -c $transcripts_file > $uncompressed_transcripts_file";
        $pipeliner->add_commands(new Command($cmd, "gunzip_transcripts.ok"));
        $transcripts_file = "$uncompressed_transcripts_file";
        
        if ($uncompressed_transcripts_file =~ /(fastq|fq)$/i) {
            # convert from fastq to fasta
            $cmd = "seqtk seq -a $uncompressed_transcripts_file > $uncompressed_transcripts_file.fasta";
            $pipeliner->add_commands(new Command($cmd, "fastq_to_fasta_seqtk.ok"));

            $transcripts_file = "$uncompressed_transcripts_file.fasta";
        }
    }
    print STDERR "-transcripts filename after: [$transcripts_file]\n";
    
    ####################################################
    # run minimap2 to identify potential fusion transcripts
    ####################################################

    my $mm2_intermediate_output_file_prefix = "$intermediates_dir/" . basename($transcripts_file) . ".mm2";
    my $cmd = "$CTAT_MINIMAP2_DIR/ctat-minimap2 --sam-hit-only --only_chimeric -ax splice --junc-bed $MM2_splice_file -O6,24 -B4 -L -t $CPU -cs -ub -G $max_intron_length $MM2_idx $transcripts_file > $mm2_intermediate_output_file_prefix.sam";
    $pipeliner->add_commands(new Command($cmd, "run_mm2.ok"));
    
    $cmd = "$UTILDIR/SAM_to_gff3.minimap2.pl  $mm2_intermediate_output_file_prefix.sam >  $mm2_intermediate_output_file_prefix.gff3";
    $pipeliner->add_commands(new Command($cmd, "mm2_sam_to_gff3.ok"));
    
    ###############################
    ## generate initial chim report
    ###############################

    my $chims_described_outfile = "$mm2_intermediate_output_file_prefix.chims_described";
    $cmd = "$UTILDIR/genome_gff3_to_chim_summary.pl --align_gff3 $mm2_intermediate_output_file_prefix.gff3 --annot_gtf $REF_GTF --min_per_id $MIN_PER_ID  > $chims_described_outfile";
    
    $pipeliner->add_commands(new Command($cmd, "chims_described.ok") );
    
    my $chim_candidates_fasta = "$chims_described_outfile.fasta";
    $cmd = "$UTILDIR/retrieve_fusion_transcript_candidates.pl $transcripts_file $chims_described_outfile > $chim_candidates_fasta";
    $pipeliner->add_commands(new Command($cmd, "chim_candidates_fasta.ok"));

    # create FI list
    my $FI_listing = "$chims_described_outfile.FI_list";
    $cmd = "$UTILDIR/prep_FI_fusion_list.py $chims_described_outfile > $FI_listing";
    $pipeliner->add_commands(new Command($cmd, "FI_listing.ok"));

    # create FI contigs.
    $cmd = "$FI_DIR/util/fusion_pair_to_mini_genome_join.pl "
        . " --fusions $FI_listing "
        . " --gtf $REF_GTF"
        . " --genome_fa $genome_lib_dir/ref_genome.fa"
        . " --out_prefix $intermediates_dir/LR-FI_targets"
        . " --shrink_introns --max_intron_length $shrink_intron_max_length ";
    
    $pipeliner->add_commands(new Command($cmd, "FI_contigs.ok"));

    $pipeliner->run();

    ## prep for mm2
    my $FI_splice_bed = "$intermediates_dir/LR-FI_targets.gtf.mm2.splice.bed";
    my $FI_mm2 = "$intermediates_dir/LR-FI_targets.fa.mm2";
    
    &prep_minimap2_reference("$intermediates_dir/LR-FI_targets.fa", $intermediates_dir, $FI_mm2, $FI_splice_bed, "$intermediates_dir/LR-FI_targets.gtf");
    
    ## run mm2 using the chimeric candidates:
    $cmd = "$CTAT_MINIMAP2_DIR/ctat-minimap2 --sam-hit-only -ax splice --junc-bed $FI_splice_bed -O6,24 -B4 -L -t $CPU -cs -ub $FI_mm2 $chim_candidates_fasta > $intermediates_dir/LR-FI.mm2.sam";
    $pipeliner->add_commands(new Command($cmd, "LR-FI.mm2.ok"));
    
    $cmd = "$UTILDIR/SAM_to_gff3.minimap2.pl $intermediates_dir/LR-FI.mm2.sam > $intermediates_dir/LR-FI.mm2.gff3";
    $pipeliner->add_commands(new Command($cmd, "LR-FI.mm2.sam_to_gff3.ok"));

    $cmd = "$UTILDIR/LR-FI_fusion_align_extractor.pl $intermediates_dir/LR-FI_targets.gtf  $intermediates_dir/LR-FI.mm2.gff3 $intermediates_dir/LR-FI.mm2.fusion_transcripts >  $intermediates_dir/LR-FI.mm2.fusion_transcripts";
    $pipeliner->add_commands(new Command($cmd, "LR-FI.mm2.sam_to_gff3.extract_fusions.ok"));
  
    my $fusions_filename = "$intermediates_dir/LR-FI.mm2.fusion_transcripts.breakpoint_info.tsv";
    
    ###############################################
    ## Add regular FI for short reads if available.
    
    if ($left_fq ne "NA") {
        $cmd = "$FI_DIR/FusionInspector --fusions $FI_listing --genome_lib_dir $genome_lib_dir "
            . " --FI_contigs_fa $intermediates_dir/LR-FI_targets.fa --FI_contigs_gtf $intermediates_dir/LR-FI_targets.gtf "
            . " --left_fq $left_fq ";
        if ($right_fq ne "NA") {
            $cmd .= " --right_fq $right_fq ";
        }
    
        $pipeliner->add_commands(new Command($cmd, "FI_short_reads.ok"));
    
        $fusions_filename = "$intermediates_dir/mm2_and_FI_fusions_merged.tsv";

        # merge FI with the mm2 fusions
        $cmd = "$UTILDIR/merge_mm2fusion_FI.py --mm2_fusions $intermediates_dir/LR-FI.mm2.fusion_transcripts.breakpoint_info.tsv --FI_fusions FI/finspector.FusionInspector.fusions.tsv --output_file $fusions_filename";
        $pipeliner->add_commands(new Command($cmd, "merge_mm2_FI.ok"));
        
    }


    #################################
    ## Fusion Annotator
    #################################
    
    $cmd = "$FindBin::Bin/FusionAnnotator/FusionAnnotator --genome_lib_dir $genome_lib_dir --annotate $fusions_filename > $fusions_filename.wAnnot";
    $pipeliner->add_commands(new Command($cmd, "annotate_fusions.ok"));
    
    $fusions_filename = "$fusions_filename.wAnnot";
    
    ## consider this the pre-filtered preliminary report
    my $preliminary_report_file = "ctat-LR-fusion.fusion_predictions.preliminary.tsv";
    $cmd = "cp $fusions_filename $preliminary_report_file";
    $pipeliner->add_commands(new Command($cmd, "cp_to_prelim.ok"));
    
        
    ###############################################
    ## FusionFilter
    ###############################################
    
        
    $cmd = "$FindBin::Bin/FusionFilter/blast_and_promiscuity_filter.pl --fusion_preds $fusions_filename --out_prefix $fusions_filename --genome_lib_dir $genome_lib_dir";
    $pipeliner->add_commands(new Command($cmd, "blast_promisc_filter.ok"));
        

    
    if ($NO_ANNOTATION_FILTER) {
        
        $cmd = "cp $fusions_filename.post_blast_and_promiscuity_filter $output_directory/ctat-LR-fusion.fusion_predictions.tsv";
        $pipeliner->add_commands(new Command($cmd, "copy_final_predictions_to_deliverable.no_annot_filter.ok"));

    }
    else {
        
        $cmd = "$FindBin::Bin/FusionFilter/util/filter_by_annotation_rules.pl --fusions  $fusions_filename.post_blast_and_promiscuity_filter --genome_lib_dir $genome_lib_dir";
        $pipeliner->add_commands(new Command($cmd, "filter_by_annot_rules.ok"));


        $cmd = "cp $fusions_filename.post_blast_and_promiscuity_filter.annot_filter.pass $output_directory/ctat-LR-fusion.fusion_predictions.tsv";
        $pipeliner->add_commands(new Command($cmd, "copy_final_predictions_to_deliverable.ok"));

    }

    # perform final filtering.
    
    

    
    $pipeliner->run();
    

    print STDERR "\n\n\tDone. See fusion predictions at: $output_directory/ctat-LR-fusion.fusion_predictions.tsv\n\n\n";
    
    exit(0); ### stopping here now.


    
}

####
sub prep_minimap2_reference {
    my ($genome_fa, $intermediates_dir, $MM2_DB_NAME, $MM2_splice_file, $REF_GTF) = @_;

    
    my $mm2_build_ok_checkpoint = "$MM2_DB_NAME.build.ok";
    if (-e $mm2_build_ok_checkpoint) {
        print STDERR "-checkpoint exists: $mm2_build_ok_checkpoint, so skipping.\n";
    }
    else {
        
        my $mm2_prep_pipeliner = new Pipeliner(-verbose => 2,
                                               -checkpoint_dir => "$intermediates_dir/__mm2_prep_chkpts");
        
        
        my $cmd = "$CTAT_MINIMAP2_DIR/ctat-minimap2 -d $MM2_DB_NAME $genome_fa";
        $mm2_prep_pipeliner->add_commands(new Command($cmd, "mm2_prep_genome.ok"));
        
        $cmd = "$CTAT_MINIMAP2_DIR/misc/paftools.ctat.js gff2bed $REF_GTF > $MM2_splice_file";
        $mm2_prep_pipeliner->add_commands(new Command($cmd, "mm2_prep_splices.ok"));
        
        $mm2_prep_pipeliner->run();
    
        system("touch $mm2_build_ok_checkpoint");
    }
    

    return;
}
